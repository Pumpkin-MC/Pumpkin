use crate::random::RandomImpl;
use proc_macro2::{Span, TokenStream};
use quote::{ToTokens, quote};
use serde::Deserialize;
use syn::LitInt;

/// Represents different types of number providers that generate integer values.
#[derive(Deserialize, Clone, Debug)]
#[serde(tag = "type")]
pub enum NormalIntProvider {
    /// Always returns the same constant value.
    #[serde(rename = "minecraft:constant")]
    Constant(ConstantIntProvider),
    /// Returns uniformly distributed random values within an inclusive range [min, max].
    #[serde(rename = "minecraft:uniform")]
    Uniform(UniformIntProvider),
    /// Returns values biased toward the lower end of the range (triangular distribution).
    #[serde(rename = "minecraft:biased_to_bottom")]
    BiasedToBottom(BiasedToBottomIntProvider),
    /// Wraps another provider and clamps its output to a specified range.
    #[serde(rename = "minecraft:clamped")]
    Clamped(ClampedIntProvider),
    /// Returns values from a normal (Gaussian) distribution, clamped to a specified inclusive range.
    #[serde(rename = "minecraft:clamped_normal")]
    ClampedNormal(ClampedNormalIntProvider),
    /// Returns values from a weighted list where entries have different probabilities.
    #[serde(rename = "minecraft:weighted_list")]
    WeightedList(WeightedListIntProvider),
}

impl ToTokens for NormalIntProvider {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        match self {
            Self::Constant(constant) => {
                tokens.extend(quote! {
                    NormalIntProvider::Constant(#constant)
                });
            }
            Self::Uniform(uniform) => {
                tokens.extend(quote! {
                    NormalIntProvider::Uniform(#uniform)
                });
            }
            Self::BiasedToBottom(biased) => {
                tokens.extend(quote! {
                    NormalIntProvider::BiasedToBottom(#biased)
                });
            }
            Self::Clamped(clamped) => {
                tokens.extend(quote! {
                    NormalIntProvider::Clamped(#clamped)
                });
            }
            Self::ClampedNormal(clamped_normal) => {
                tokens.extend(quote! {
                    NormalIntProvider::ClampedNormal(#clamped_normal)
                });
            }
            Self::WeightedList(weighted_list) => {
                tokens.extend(quote! {
                    NormalIntProvider::WeightedList(#weighted_list)
                });
            }
        }
    }
}

/// A flexible integer provider that can be either a constant value or a complex provider.
#[derive(Deserialize, Clone, Debug)]
#[serde(untagged)]
pub enum IntProvider {
    /// A complex provider with configurable distribution.
    Object(NormalIntProvider),
    /// A simple constant integer value.
    Constant(i32),
}

impl ToTokens for IntProvider {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        match self {
            Self::Object(int_provider) => {
                tokens.extend(quote! {
                    IntProvider::Object(#int_provider)
                });
            }
            Self::Constant(i) => tokens.extend(quote! {
                IntProvider::Constant(#i)
            }),
        }
    }
}

impl IntProvider {
    /// Returns the minimum possible value this provider can generate.
    ///
    /// # Returns
    /// The minimum value (inclusive) that can be generated by this provider.
    #[must_use]
    pub fn get_min(&self) -> i32 {
        match self {
            Self::Object(int_provider) => match int_provider {
                NormalIntProvider::Constant(constant) => constant.get_min(),
                NormalIntProvider::Uniform(uniform) => uniform.get_min(),
                NormalIntProvider::BiasedToBottom(biased) => biased.get_min(),
                NormalIntProvider::Clamped(clamped) => clamped.get_min(),
                NormalIntProvider::ClampedNormal(clamped_normal) => clamped_normal.get_min(),
                NormalIntProvider::WeightedList(weighted_list) => weighted_list.get_min(),
            },
            Self::Constant(i) => *i,
        }
    }

    /// Generates a random integer value using the configured distribution.
    ///
    /// # Arguments
    /// - `random` – The random number generator to use.
    ///
    /// # Returns
    /// A random integer value according to the provider's distribution strategy.
    pub fn get(&self, random: &mut impl RandomImpl) -> i32 {
        match self {
            Self::Object(int_provider) => match int_provider {
                NormalIntProvider::Constant(constant) => constant.get(random),
                NormalIntProvider::Uniform(uniform) => uniform.get(random),
                NormalIntProvider::BiasedToBottom(biased) => biased.get(random),
                NormalIntProvider::Clamped(clamped) => clamped.get(random),
                NormalIntProvider::ClampedNormal(clamped_normal) => clamped_normal.get(random),
                NormalIntProvider::WeightedList(weighted_list) => weighted_list.get(random),
            },
            Self::Constant(i) => *i,
        }
    }

    /// Returns the maximum possible value this provider can generate.
    ///
    /// # Returns
    /// The maximum value (inclusive) that can be generated by this provider.
    #[must_use]
    pub fn get_max(&self) -> i32 {
        match self {
            Self::Object(int_provider) => match int_provider {
                NormalIntProvider::Constant(constant) => constant.get_max(),
                NormalIntProvider::Uniform(uniform) => uniform.get_max(),
                NormalIntProvider::BiasedToBottom(biased) => biased.get_max(),
                NormalIntProvider::Clamped(clamped) => clamped.get_max(),
                NormalIntProvider::ClampedNormal(clamped_normal) => clamped_normal.get_max(),
                NormalIntProvider::WeightedList(weighted_list) => weighted_list.get_max(),
            },
            Self::Constant(i) => *i,
        }
    }
}

/// An integer provider that always returns the same constant value.
#[derive(Deserialize, Clone, Debug)]
pub struct ConstantIntProvider {
    /// The constant value that will always be returned.
    pub value: i32,
}

impl ToTokens for ConstantIntProvider {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        let value = LitInt::new(&self.value.to_string(), Span::call_site());
        tokens.extend(quote! {
            ConstantIntProvider { value: #value }
        });
    }
}

impl ConstantIntProvider {
    /// Creates a new constant provider with the given value.
    ///
    /// # Arguments
    /// - `value` – The constant value to return.
    ///
    /// # Returns
    /// A new `ConstantIntProvider` instance.
    #[must_use]
    pub const fn new(value: i32) -> Self {
        Self { value }
    }

    /// Returns the minimum value (same as the constant value).
    ///
    /// # Returns
    /// The constant value.
    #[must_use]
    pub const fn get_min(&self) -> i32 {
        self.value
    }

    /// Returns the constant value, ignoring the random number generator.
    ///
    /// # Arguments
    /// - `_random` – The random number generator (unused).
    ///
    /// # Returns
    /// The constant value.
    pub const fn get(&self, _random: &mut impl RandomImpl) -> i32 {
        self.value
    }

    /// Returns the maximum value (same as the constant value).
    ///
    /// # Returns
    /// The constant value.
    #[must_use]
    pub const fn get_max(&self) -> i32 {
        self.value
    }
}

/// An integer provider that generates values biased toward the lower end of the range.
#[derive(Deserialize, Clone, Debug)]
pub struct BiasedToBottomIntProvider {
    /// The minimum value (inclusive) that can be generated.
    pub min_inclusive: i32,
    /// The maximum value (inclusive) that can be generated.
    pub max_inclusive: i32,
}

impl ToTokens for BiasedToBottomIntProvider {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        let min_inclusive = LitInt::new(&self.min_inclusive.to_string(), Span::call_site());
        let max_inclusive = LitInt::new(&self.max_inclusive.to_string(), Span::call_site());
        tokens.extend(quote! {
            BiasedToBottomIntProvider { min_inclusive: #min_inclusive, max_inclusive: #max_inclusive }
        });
    }
}

impl BiasedToBottomIntProvider {
    /// Creates a new biased-to-bottom provider with the specified range.
    ///
    /// # Arguments
    /// - `min_inclusive` – The minimum value (inclusive).
    /// - `max_inclusive` – The maximum value (inclusive).
    ///
    /// # Returns
    /// A new `BiasedToBottomIntProvider` instance.
    #[must_use]
    pub const fn new(min_inclusive: i32, max_inclusive: i32) -> Self {
        Self {
            min_inclusive,
            max_inclusive,
        }
    }

    /// Returns the minimum inclusive value.
    ///
    /// # Returns
    /// The minimum value that can be generated (inclusive).
    #[must_use]
    pub const fn get_min(&self) -> i32 {
        self.min_inclusive
    }

    /// Generates a random value biased toward the lower end of the range.
    ///
    /// # Arguments
    /// - `random` – The random number generator to use.
    ///
    /// # Returns
    /// A random integer in the range [min_inclusive, max_inclusive], with lower values more likely.
    pub fn get(&self, random: &mut impl RandomImpl) -> i32 {
        // Similar to uniform but biased toward lower values
        // Uses triangular distribution with mode at min
        let range = f64::from(self.max_inclusive - self.min_inclusive + 1);
        let triangular = random.next_triangular(0.0, range);
        self.min_inclusive + (triangular.abs() as i32).min(self.max_inclusive - self.min_inclusive)
    }

    /// Returns the maximum inclusive value.
    ///
    /// # Returns
    /// The maximum value that can be generated (inclusive).
    #[must_use]
    pub const fn get_max(&self) -> i32 {
        self.max_inclusive
    }
}

/// An integer provider that wraps another provider and clamps its output.
#[derive(Deserialize, Clone, Debug)]
pub struct ClampedIntProvider {
    /// The source provider to get values from.
    pub source: Box<IntProvider>,
    /// The minimum value (inclusive) to clamp to.
    pub min_inclusive: i32,
    /// The maximum value (inclusive) to clamp to.
    pub max_inclusive: i32,
}

impl ToTokens for ClampedIntProvider {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        let source = &self.source;
        let min_inclusive = LitInt::new(&self.min_inclusive.to_string(), Span::call_site());
        let max_inclusive = LitInt::new(&self.max_inclusive.to_string(), Span::call_site());
        tokens.extend(quote! {
            ClampedIntProvider {
                source: Box::new(#source),
                min_inclusive: #min_inclusive,
                max_inclusive: #max_inclusive
            }
        });
    }
}

impl ClampedIntProvider {
    /// Creates a new clamped provider with the specified source and range.
    ///
    /// # Arguments
    /// - `source` – The source provider to get values from.
    /// - `min_inclusive` – The minimum value (inclusive) to clamp to.
    /// - `max_inclusive` – The maximum value (inclusive) to clamp to.
    ///
    /// # Returns
    /// A new `ClampedIntProvider` instance.
    #[must_use]
    pub fn new(source: IntProvider, min_inclusive: i32, max_inclusive: i32) -> Self {
        Self {
            source: Box::new(source),
            min_inclusive,
            max_inclusive,
        }
    }

    /// Returns the minimum value after clamping.
    ///
    /// # Returns
    /// The larger of the source's minimum and the clamp minimum.
    #[must_use]
    pub fn get_min(&self) -> i32 {
        self.min_inclusive.max(self.source.get_min())
    }

    /// Generates a random value from the source and clamps it to the configured range.
    ///
    /// # Arguments
    /// - `random` – The random number generator to use.
    ///
    /// # Returns
    /// A random integer from the source provider, clamped to [min_inclusive, max_inclusive].
    pub fn get(&self, random: &mut impl RandomImpl) -> i32 {
        self.source
            .get(random)
            .clamp(self.min_inclusive, self.max_inclusive)
    }

    /// Returns the maximum value after clamping.
    ///
    /// # Returns
    /// The smaller of the source's maximum and the clamp maximum.
    #[must_use]
    pub fn get_max(&self) -> i32 {
        self.max_inclusive.min(self.source.get_max())
    }
}

/// An integer provider that generates values from a clamped normal distribution.
#[derive(Deserialize, Clone, Debug)]
pub struct ClampedNormalIntProvider {
    /// The mean (centre) of the normal distribution.
    pub mean: f32,
    /// The standard deviation of the normal distribution.
    pub deviation: f32,
    /// The minimum inclusive clamp value.
    pub min_inclusive: i32,
    /// The maximum inclusive clamp value.
    pub max_inclusive: i32,
}

impl ToTokens for ClampedNormalIntProvider {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        let mean = syn::LitFloat::new(&self.mean.to_string(), Span::call_site());
        let deviation = syn::LitFloat::new(&self.deviation.to_string(), Span::call_site());
        let min_inclusive = LitInt::new(&self.min_inclusive.to_string(), Span::call_site());
        let max_inclusive = LitInt::new(&self.max_inclusive.to_string(), Span::call_site());
        tokens.extend(quote! {
            ClampedNormalIntProvider {
                mean: #mean,
                deviation: #deviation,
                min_inclusive: #min_inclusive,
                max_inclusive: #max_inclusive
            }
        });
    }
}

impl ClampedNormalIntProvider {
    /// Creates a new clamped normal provider with the specified parameters.
    ///
    /// # Arguments
    /// - `mean` – The mean (centre) of the normal distribution.
    /// - `deviation` – The standard deviation of the normal distribution.
    /// - `min_inclusive` – The minimum inclusive clamp value.
    /// - `max_inclusive` – The maximum inclusive clamp value.
    ///
    /// # Returns
    /// A new `ClampedNormalIntProvider` instance.
    #[must_use]
    pub const fn new(mean: f32, deviation: f32, min_inclusive: i32, max_inclusive: i32) -> Self {
        Self {
            mean,
            deviation,
            min_inclusive,
            max_inclusive,
        }
    }

    /// Returns the minimum inclusive clamp value.
    ///
    /// # Returns
    /// The minimum value that can be generated after clamping.
    #[must_use]
    pub const fn get_min(&self) -> i32 {
        self.min_inclusive
    }

    /// Generates a random value from the clamped normal distribution.
    ///
    /// # Arguments
    /// - `random` – The random number generator to use.
    ///
    /// # Returns
    /// A random integer from a normal distribution, rounded and clamped to [min_inclusive, max_inclusive].
    pub fn get(&self, random: &mut impl RandomImpl) -> i32 {
        // NOTE: Generate a normal distribution value and clamp to range
        let gaussian = random.next_gaussian() as f32;
        let value = gaussian.mul_add(self.deviation, self.mean).round() as i32;
        value.clamp(self.min_inclusive, self.max_inclusive)
    }

    /// Returns the maximum inclusive clamp value.
    ///
    /// # Returns
    /// The maximum value that can be generated after clamping.
    #[must_use]
    pub const fn get_max(&self) -> i32 {
        self.max_inclusive
    }
}

/// A weighted entry in a weighted list provider.
#[derive(Deserialize, Clone, Debug)]
pub struct WeightedEntry {
    /// The integer provider that generates the value for this entry.
    pub data: IntProvider,
    /// The weight (probability) of this entry being chosen.
    pub weight: i32,
}

impl ToTokens for WeightedEntry {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        let data = &self.data;
        let weight = LitInt::new(&self.weight.to_string(), Span::call_site());
        tokens.extend(quote! {
            WeightedEntry { data: #data, weight: #weight }
        });
    }
}

/// An integer provider that selects values from a weighted list.
#[derive(Deserialize, Clone, Debug)]
pub struct WeightedListIntProvider {
    /// The list of weighted entries to choose from.
    pub distribution: Vec<WeightedEntry>,
}

impl ToTokens for WeightedListIntProvider {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        let distribution = &self.distribution;
        tokens.extend(quote! {
            WeightedListIntProvider { distribution: vec![#(#distribution),*] }
        });
    }
}

impl WeightedListIntProvider {
    /// Creates a new weighted list provider with the given distribution.
    ///
    /// # Arguments
    /// - `distribution` – The list of weighted entries.
    ///
    /// # Returns
    /// A new `WeightedListIntProvider` instance.
    #[must_use]
    pub const fn new(distribution: Vec<WeightedEntry>) -> Self {
        Self { distribution }
    }

    /// Returns the minimum possible value from all entries.
    ///
    /// # Returns
    /// The smallest minimum value among all entries, or 0 if the list is empty.
    #[must_use]
    pub fn get_min(&self) -> i32 {
        self.distribution
            .iter()
            .map(|entry| entry.data.get_min())
            .min()
            .unwrap_or(0)
    }

    /// Selects a random entry based on weights and generates a value from it.
    ///
    /// # Arguments
    /// - `random` – The random number generator to use.
    ///
    /// # Returns
    /// A random integer from the chosen weighted entry, or 0 if the list is empty.
    pub fn get(&self, random: &mut impl RandomImpl) -> i32 {
        if self.distribution.is_empty() {
            return 0;
        }

        // Calculate total weight.
        let total_weight: i32 = self.distribution.iter().map(|entry| entry.weight).sum();

        if total_weight == 0 {
            return 0;
        }

        // Choose a random weight.
        let chosen_weight = random.next_bounded_i32(total_weight);
        let mut current_weight = 0;

        // Find the entry corresponding to the chosen weight.
        for entry in &self.distribution {
            current_weight += entry.weight;
            if chosen_weight < current_weight {
                return entry.data.get(random);
            }
        }

        // Fallback to the last entry.
        self.distribution.last().unwrap().data.get(random)
    }

    /// Returns the maximum possible value from all entries.
    ///
    /// # Returns
    /// The largest maximum value among all entries, or 0 if the list is empty.
    #[must_use]
    pub fn get_max(&self) -> i32 {
        self.distribution
            .iter()
            .map(|entry| entry.data.get_max())
            .max()
            .unwrap_or(0)
    }
}

/// An integer provider that generates uniformly distributed random values.
#[derive(Deserialize, Clone, Debug)]
pub struct UniformIntProvider {
    /// The minimum value (inclusive) that can be generated.
    pub min_inclusive: i32,
    /// The maximum value (inclusive) that can be generated.
    pub max_inclusive: i32,
}

impl ToTokens for UniformIntProvider {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        let min_inclusive = LitInt::new(&self.min_inclusive.to_string(), Span::call_site());
        let max_inclusive = LitInt::new(&self.max_inclusive.to_string(), Span::call_site());

        tokens.extend(quote! {
            UniformIntProvider { min_inclusive: #min_inclusive, max_inclusive: #max_inclusive }
        });
    }
}

impl UniformIntProvider {
    /// Creates a new uniform provider with the specified inclusive range.
    ///
    /// # Arguments
    /// - `min_inclusive` – The minimum value (inclusive).
    /// - `max_inclusive` – The maximum value (inclusive).
    ///
    /// # Returns
    /// A new `UniformIntProvider` instance.
    #[must_use]
    pub const fn new(min_inclusive: i32, max_inclusive: i32) -> Self {
        Self {
            min_inclusive,
            max_inclusive,
        }
    }

    /// Returns the minimum inclusive value.
    ///
    /// # Returns
    /// The minimum value that can be generated (inclusive).
    #[must_use]
    pub const fn get_min(&self) -> i32 {
        self.min_inclusive
    }

    /// Generates a uniformly distributed random value in the configured range.
    ///
    /// # Arguments
    /// - `random` – The random number generator to use.
    ///
    /// # Returns
    /// A random integer in the inclusive range [min_inclusive, max_inclusive].
    pub fn get(&self, random: &mut impl RandomImpl) -> i32 {
        random.next_inbetween_i32(self.min_inclusive, self.max_inclusive)
    }

    /// Returns the maximum inclusive value.
    ///
    /// # Returns
    /// The maximum value that can be generated (inclusive).
    #[must_use]
    pub const fn get_max(&self) -> i32 {
        self.max_inclusive
    }
}

/// Tests for the integer provider implementations.
#[cfg(test)]
mod tests {
    use super::*;
    use crate::random::{RandomGenerator, get_seed};

    #[test]
    fn constant_int_provider() {
        let mut random = RandomGenerator::Xoroshiro(
            crate::random::xoroshiro128::Xoroshiro::from_seed(get_seed()),
        );
        let provider = ConstantIntProvider::new(42);

        assert_eq!(provider.get_min(), 42);
        assert_eq!(provider.get_max(), 42);
        assert_eq!(provider.get(&mut random), 42);
        assert_eq!(provider.get(&mut random), 42); // Should always return the same value
    }

    #[test]
    fn uniform_int_provider() {
        let mut random = RandomGenerator::Xoroshiro(
            crate::random::xoroshiro128::Xoroshiro::from_seed(get_seed()),
        );
        let provider = UniformIntProvider::new(1, 10);

        assert_eq!(provider.get_min(), 1);
        assert_eq!(provider.get_max(), 10);

        // Test that values are within range
        for _ in 0..100 {
            let value = provider.get(&mut random);
            assert!(
                (1..=10).contains(&value),
                "Value {value} is outside range [1, 10]"
            );
        }
    }

    #[test]
    fn biased_to_bottom_int_provider() {
        let mut random = RandomGenerator::Xoroshiro(
            crate::random::xoroshiro128::Xoroshiro::from_seed(get_seed()),
        );
        let provider = BiasedToBottomIntProvider::new(1, 20);

        assert_eq!(provider.get_min(), 1);
        assert_eq!(provider.get_max(), 20);

        // Test that values are within range (biased toward lower values)
        for _ in 0..100 {
            let value = provider.get(&mut random);
            assert!(
                (1..=20).contains(&value),
                "Value {value} is outside range [1, 20]"
            );
        }
    }

    #[test]
    fn clamped_normal_int_provider() {
        let mut random = RandomGenerator::Xoroshiro(
            crate::random::xoroshiro128::Xoroshiro::from_seed(get_seed()),
        );
        let provider = ClampedNormalIntProvider::new(5.0, 2.0, 1, 10);

        assert_eq!(provider.get_min(), 1);
        assert_eq!(provider.get_max(), 10);

        // Test that values are within range
        for _ in 0..100 {
            let value = provider.get(&mut random);
            assert!(
                (1..=10).contains(&value),
                "Value {value} is outside range [1, 10]"
            );
        }
    }

    #[test]
    fn clamped_int_provider() {
        let mut random = RandomGenerator::Xoroshiro(
            crate::random::xoroshiro128::Xoroshiro::from_seed(get_seed()),
        );
        let source =
            IntProvider::Object(NormalIntProvider::Uniform(UniformIntProvider::new(1, 100)));
        let provider = ClampedIntProvider::new(source, 5, 15);

        assert_eq!(provider.get_min(), 5);
        assert_eq!(provider.get_max(), 15);

        // Test that values are within a clamped range.
        for _ in 0..100 {
            let value = provider.get(&mut random);
            assert!(
                (5..=15).contains(&value),
                "Value {value} is outside clamped range [5, 15]"
            );
        }
    }

    #[test]
    fn weighted_list_int_provider() {
        let mut random = RandomGenerator::Xoroshiro(
            crate::random::xoroshiro128::Xoroshiro::from_seed(get_seed()),
        );

        let entries = vec![
            WeightedEntry {
                data: IntProvider::Constant(1),
                weight: 10,
            },
            WeightedEntry {
                data: IntProvider::Constant(2),
                weight: 20,
            },
            WeightedEntry {
                data: IntProvider::Constant(3),
                weight: 5,
            },
        ];

        let provider = WeightedListIntProvider::new(entries);

        assert_eq!(provider.get_min(), 1);
        assert_eq!(provider.get_max(), 3);

        // Test that values are from the weighted list
        for _ in 0..100 {
            let value = provider.get(&mut random);
            assert!(
                (1..=3).contains(&value),
                "Value {value} is not from the weighted list"
            );
        }
    }

    #[test]
    fn int_provider_enum_constant() {
        let mut random = RandomGenerator::Xoroshiro(
            crate::random::xoroshiro128::Xoroshiro::from_seed(get_seed()),
        );
        let provider = IntProvider::Constant(25);

        assert_eq!(provider.get_min(), 25);
        assert_eq!(provider.get_max(), 25);
        assert_eq!(provider.get(&mut random), 25);
    }

    #[test]
    fn int_provider_enum_object() {
        let mut random = RandomGenerator::Xoroshiro(
            crate::random::xoroshiro128::Xoroshiro::from_seed(get_seed()),
        );
        let uniform = UniformIntProvider::new(5, 15);
        let provider = IntProvider::Object(NormalIntProvider::Uniform(uniform));

        assert_eq!(provider.get_min(), 5);
        assert_eq!(provider.get_max(), 15);

        let value = provider.get(&mut random);
        assert!(
            (5..=15).contains(&value),
            "Value {value} is outside range [5, 15]"
        );
    }
}
